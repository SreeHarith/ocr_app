

=== FILE: \src\app\api\ocr\route.ts ===

import { NextRequest, NextResponse } from 'next/server';

// Function to call the Gender-API.com API
async function getGender(name: string, apiKey: string) {
  const firstName = name.split(' ')[0];
  try {
    const response = await fetch(`https://gender-api.com/get?name=${firstName}&key=${apiKey}`);
    const data = await response.json();
    if (data.errno) {
      console.error("Gender-API.com Error:", data.errmsg);
      return 'unknown';
    }
    return data.gender || 'unknown';
  } catch (error) {
    console.error("Gender-API.com call failed:", error);
    return 'unknown';
  }
}

export async function POST(request: NextRequest) {
  // This route now expects a JSON body with an `imageUrl`.
  const { imageUrl } = await request.json();
  const genderApiKey = process.env.GENDER_API_KEY!;
  console.log("URL being sent to OCR AI:", imageUrl);
  if (!imageUrl) {
    return NextResponse.json({ error: 'No image URL provided' }, { status: 400 });
  }

  try {
    const ocrResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'qwen/qwen2.5-vl-72b-instruct:free',
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: 'You are an expert OCR system. Analyze the entire image and find ALL names and phone numbers. You MUST return ONLY a single, clean JSON array. Each object must have two keys: "name" and "phone". Example: [{"name": "John Doe", "phone": "111-222-3300"}]',
              },
              // The AI is now given the public URL of the image on Cloudinary.
              { type: 'image_url', image_url: { url: imageUrl } },
            ],
          },
        ],
      }),
    });

    const ocrData = await ocrResponse.json();

    if (!ocrResponse.ok || !ocrData.choices || ocrData.choices.length === 0) {
      console.error("OCR API Error Response:", ocrData);
      throw new Error(`OCR API call failed. Response: ${JSON.stringify(ocrData)}`);
    }

    const content = ocrData.choices[0].message.content;
    const jsonString = content.match(/```json\n([\s\S]*?)\n```/)?.[1] || content;
    const contacts: { name: string; phone: string }[] = JSON.parse(jsonString);

    const contactsWithGender = await Promise.all(
      contacts.map(async (contact) => {
        const gender = await getGender(contact.name, genderApiKey);
        return { ...contact, gender };
      })
    );

    return NextResponse.json(contactsWithGender);

  } catch (error) {
    console.error(error);
    return NextResponse.json({ error: 'Failed to process the image.' }, { status: 500 });
  }
}


=== FILE: \src\app\api\upload\route.ts ===

import { NextRequest, NextResponse } from 'next/server';
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary with your credentials
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function POST(request: NextRequest) {
  const formData = await request.formData();
  const file = formData.get('file') as File;

  if (!file) {
    return NextResponse.json({ error: "No file provided." }, { status: 400 });
  }

  // Convert the file to a buffer
  const buffer = await file.arrayBuffer();
  const bytes = Buffer.from(buffer);

  try {
    // Upload the image to Cloudinary. We're using a Promise to handle the stream.
    const result: any = await new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'ocr-uploads',
          // This transformation creates the JPG version on Cloudinary's servers.
          transformation: [
            { width: 1200, height: 1200, crop: 'limit' },
            { format: 'jpg', quality: 'auto:good' }
          ]
        },
        (error, result) => {
          if (error) {
            reject(error);
          } else {
            resolve(result);
          }
        }
      );
      uploadStream.end(bytes);
    });

    // ================== THE FIX IS HERE ==================
    // The result.secure_url points to the original .heic file.
    // We manually change the extension to .jpg to get the URL for the converted version.
    const transformedUrl = result.secure_url.replace(/\.heic$/i, ".jpg");
    // =====================================================

    // Return the secure URL of the newly converted and optimized JPG image
    return NextResponse.json({ url: transformedUrl });

  } catch (error) {
    console.error("Cloudinary upload error:", error);
    return NextResponse.json({ error: "Failed to upload image to Cloudinary." }, { status: 500 });
  }
}


=== FILE: \src\app\page.tsx ===

'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { YourDataTable } from '@/components/your-data-table';
import EditDialog from '@/components/edit-dialog';
import { Contact } from '@/components/columns';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"
import { CSVLink } from 'react-csv';
import { Download } from 'lucide-react';


export default function Home() {
  const [file, setFile] = useState<File | null>(null);
  const [extractedInfo, setExtractedInfo] = useState<Contact[]>([]);
  const [tableData, setTableData] = useState<Contact[]>([]);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [imagePreviewUrl, setImagePreviewUrl] = useState<string | null>(null);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [isNotFoundDialogOpen, setIsNotFoundDialogOpen] = useState(false);

  const csvHeaders = [
    { label: "Name", key: "name" },
    { label: "Phone Number", key: "phone" },
    { label: "Gender", key: "gender" }
  ];

  const getCSVData = () => {
    return tableData.map(contact => ({
      ...contact,
      phone: `\t${contact.phone}`
    }));
  };

  useEffect(() => {
    return () => {
      if (imagePreviewUrl) URL.revokeObjectURL(imagePreviewUrl);
    };
  }, [imagePreviewUrl]);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (imagePreviewUrl) URL.revokeObjectURL(imagePreviewUrl);
    const newFile = event.target.files?.[0];
    if (newFile) {
      setFile(newFile);
      setImagePreviewUrl(URL.createObjectURL(newFile));
    } else {
      setFile(null);
      setImagePreviewUrl(null);
    }
  };

  const handleExtractClick = async () => {
    if (!file) {
      alert('Please select a file first.');
      return;
    }
    setIsLoading(true);

    try {
      // Step 1: Upload the image file to our backend, which forwards it to Cloudinary.
      const formData = new FormData();
      formData.append('file', file);

      const uploadResponse = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      const uploadData = await uploadResponse.json();
      if (!uploadResponse.ok) {
        throw new Error(uploadData.error || 'Failed to upload image.');
      }
      
      const imageUrl = uploadData.url;

      // Step 2: Send the public image URL to the OCR API.
      const ocrResponse = await fetch('/api/ocr', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ imageUrl }), // Send the URL in the body
      });

      const ocrData = await ocrResponse.json();
      if (!ocrResponse.ok) {
        throw new Error(ocrData.error || 'Failed to process image with OCR.');
      }

      if (Array.isArray(ocrData) && ocrData.length > 0) {
        setExtractedInfo(ocrData);
        setIsDialogOpen(true);
      } else {
        setIsNotFoundDialogOpen(true);
      }

    } catch (error: any) {
      console.error('An error occurred during extraction:', error);
      alert(`An error occurred: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSave = (data: Contact[]) => {
    if (editingIndex !== null) {
      const updatedTableData = [...tableData];
      updatedTableData[editingIndex] = data[0];
      setTableData(updatedTableData);
      setEditingIndex(null);
    } else {
      setTableData((prevData) => [...prevData, ...data]);
    }
    setIsDialogOpen(false);
  };

  const handleDeleteRow = (index: number) => {
    if (confirm('Are you sure you want to delete this contact?')) {
      setTableData((prevData) => prevData.filter((_, i) => i !== index));
    }
  };

  const handleEditRow = (index: number, contact: Contact) => {
    setEditingIndex(index);
    setExtractedInfo([contact]);
    setIsDialogOpen(true);
  };

  return (
    <main className="container mx-auto p-4 md:p-8">
      <div className="max-w-4xl mx-auto">
        <header className="mb-8 text-center">
          <h1 className="text-3xl md:text-4xl font-bold">OCR Contact Extractor</h1>
          <p className="text-muted-foreground mt-2">
            Upload an image to extract all names and phone numbers.
          </p>
        </header>

        <div className="flex flex-col sm:flex-row items-center justify-center gap-4 p-6 border rounded-lg bg-card shadow-sm mb-8">
          <Input 
            id="picture" 
            type="file" 
            onChange={handleFileChange} 
            className="max-w-xs cursor-pointer"
            accept="image/png, image/jpeg, image/webp"
          />
          <Button onClick={handleExtractClick} disabled={!file || isLoading}>
            {isLoading ? 'Processing...' : 'Extract Information'}
          </Button>
        </div>

        {imagePreviewUrl && (
          <div className="mb-8">
            <h2 className="text-xl font-semibold mb-4 text-center">Image Preview</h2>
            <div className="flex justify-center">
              <div className="p-2 border-2 border-dashed rounded-lg">
                <img 
                  src={imagePreviewUrl} 
                  alt="Uploaded contact card" 
                  className="max-w-md max-h-96 rounded-md object-contain"
                />
              </div>
            </div>
          </div>
        )}
        
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-semibold">Saved Contacts</h2>
          {tableData.length > 0 && (
            <CSVLink 
              data={getCSVData()} 
              headers={csvHeaders}
              filename={"contacts.csv"}
              className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-secondary text-secondary-foreground hover:bg-secondary/80 h-10 px-4 py-2"
            >
              <Download className="mr-2 h-4 w-4" />
              Download CSV
            </CSVLink>
          )}
        </div>
        
        <YourDataTable 
          data={tableData} 
          handleDeleteRow={handleDeleteRow}
          handleEditRow={handleEditRow}
        />

        <EditDialog
          isOpen={isDialogOpen}
          setIsOpen={setIsDialogOpen}
          data={extractedInfo}
          onSave={handleSave}
        />
        
        <AlertDialog open={isNotFoundDialogOpen} onOpenChange={setIsNotFoundDialogOpen}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>No Contacts Found</AlertDialogTitle>
              <AlertDialogDescription>
                We could not detect a name or phone number in the uploaded image. Please try a different image or one with clearer text.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogAction>OK</AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </main>
  );
}


=== FILE: \src\components\columns.tsx ===

"use client"

import { ColumnDef } from "@tanstack/react-table"
import { Button } from "@/components/ui/button"
import { Edit, Trash2 } from "lucide-react"

export type Contact = {
  name: string
  phone: string
  gender: string // Add gender field
}

export const columns: ColumnDef<Contact>[] = [
  {
    accessorKey: "name",
    header: "Name",
  },
  {
    accessorKey: "phone",
    header: "Phone Number",
  },
  // NEW GENDER COLUMN
  {
    accessorKey: "gender",
    header: "Gender",
    cell: ({ row }) => {
      const gender = row.getValue("gender") as string;
      // Capitalize the first letter for display
      return <div className="capitalize">{gender}</div>;
    },
  },
  {
    id: "actions",
    header: () => <div className="text-right">Actions</div>,
    cell: ({ row, table }) => {
      // ... (action cell code is unchanged)
      const contact = row.original
      return (
        <div className="text-right">
          <Button
            variant="ghost"
            size="icon"
            // @ts-ignore
            onClick={() => table.options.meta?.handleEditRow(row.index, contact)}
            className="mr-2"
          >
            <Edit className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            // @ts-ignore
            onClick={() => table.options.meta?.handleDeleteRow(row.index)}
          >
            <Trash2 className="h-4 w-4 text-red-500" />
          </Button>
        </div>
      )
    },
  },
]

=== FILE: \src\components\edit-dialog.tsx ===

"use client"

import { useEffect, useState } from "react"
import React from "react" // Import React for Fragments
import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Input } from "@/components/ui/input"
import { Trash2, PlusCircle, AlertCircle } from "lucide-react"
import { cn } from "@/lib/utils"
import { parsePhoneNumberFromString, CountryCode } from "libphonenumber-js"

interface ContactInfo {
  name: string;
  phone: string;
  gender: string;
}

interface EditDialogProps {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  data: ContactInfo[];
  onSave: (data: ContactInfo[]) => void;
}

interface DuplicateInfo {
  isDuplicate: boolean;
  originalIndex: number | null;
}

const DEFAULT_COUNTRY: CountryCode = "IN";
type AcceptType = string;
const ACCEPT_TYPE: AcceptType = "any";

const normalizeAndParse = (raw: string, country?: CountryCode) => {
  const input = raw?.trim() ?? "";
  if (!input) return { parsed: null as ReturnType<typeof parsePhoneNumberFromString> | null, normalized: "" };
  const parsedIntl = parsePhoneNumberFromString(input);
  if (parsedIntl) return { parsed: parsedIntl, normalized: parsedIntl.number };
  const parsedWithCountry = parsePhoneNumberFromString(input, country || DEFAULT_COUNTRY);
  if (parsedWithCountry) return { parsed: parsedWithCountry, normalized: parsedWithCountry.number };
  const justDigitsPlus = input.replace(/[^\d+]/g, "");
  const retryIntl = parsePhoneNumberFromString(justDigitsPlus);
  if (retryIntl) return { parsed: retryIntl, normalized: retryIntl.number };
  const retryCountry = parsePhoneNumberFromString(justDigitsPlus, country || DEFAULT_COUNTRY);
  if (retryCountry) return { parsed: retryCountry, normalized: retryCountry.number };
  return { parsed: null, normalized: "" };
};

// ================== UPDATED VALIDATION FUNCTION ==================
const getValidationError = (raw: string, country?: CountryCode): string | null => {
  if (!raw || !raw.trim()) return null;

  const { parsed } = normalizeAndParse(raw, country);

  if (!parsed) {
    return "Invalid phone number format";
  }

  // 1. General validation by the library
  if (!parsed.isValid()) {
    return "Invalid phone number";
  }

  // 2. Stricter custom rule for India
  if (parsed.country === 'IN') {
    const nationalNumber = parsed.nationalNumber;
    // Valid Indian numbers must be 10 digits and start with 6, 7, 8, or 9.
    if (!/^[6789]\d{9}$/.test(nationalNumber)) {
      return "Invalid Indian number";
    }
  }

  // 3. Mobile-only check (if enabled)
  if (ACCEPT_TYPE === "mobile") {
    const t: string | undefined = parsed.getType?.();
    if (t && t !== "MOBILE" && t !== "FIXED_LINE_OR_MOBILE") {
      return "Must be a mobile number";
    }
  }

  return null;
};
// =================================================================

const toE164 = (raw: string, country?: CountryCode): string => {
  const { parsed } = normalizeAndParse(raw, country);
  return parsed?.number ?? (raw?.trim() ?? "");
};

export default function EditDialog({ isOpen, setIsOpen, data, onSave }: EditDialogProps) {
  const [editedData, setEditedData] = useState<ContactInfo[]>([]);
  const [validationErrors, setValidationErrors] = useState<Record<number, string>>({});

  useEffect(() => {
    if (data) {
      setEditedData(data);
      validateAllPhones(data);
    }
  }, [data]);

  const validatePhone = (phone: string, index: number, country?: CountryCode) => {
    const error = getValidationError(phone, country);
    if (error) {
      setValidationErrors(prev => ({ ...prev, [index]: error }));
    } else {
      setValidationErrors(prev => {
        const next = { ...prev };
        delete next[index];
        return next;
      });
    }
  };

  const validateAllPhones = (contacts: ContactInfo[]) => {
    const errors: Record<number, string> = {};
    contacts.forEach((contact, index) => {
      const error = getValidationError(contact.phone);
      if (error) errors[index] = error;
    });
    setValidationErrors(errors);
  };

  const handleInputChange = (index: number, field: 'name' | 'phone' | 'gender', value: string) => {
    const updated = [...editedData];
    // @ts-ignore
    updated[index][field] = value;
    setEditedData(updated);
    if (field === 'phone') {
      validatePhone(value, index);
    }
  };

  const removeContact = (index: number) => {
    const next = editedData.filter((_, i) => i !== index);
    setEditedData(next);
    validateAllPhones(next);
  };

  const addContact = () => {
    setEditedData([
      ...editedData,
      { name: "", phone: "", gender: "unknown" },
    ]);
  };

  const getDuplicateInfo = (currentIndex: number): DuplicateInfo => {
    const currentContact = editedData[currentIndex];
    const currentPhone = currentContact.phone.trim();
    if (!currentPhone) return { isDuplicate: false, originalIndex: null };
    const currentE164 = toE164(currentPhone);
    for (let i = 0; i < currentIndex; i++) {
      const prevContact = editedData[i];
      const prevE164 = toE164(prevContact.phone);
      if (prevE164 && currentE164 && prevE164 === currentE164) {
        return { isDuplicate: true, originalIndex: i };
      }
    }
    return { isDuplicate: false, originalIndex: null };
  };

  const handleSaveClick = () => {
    if (Object.keys(validationErrors).length > 0) {
      alert("Please fix the invalid phone numbers before saving.");
      return;
    }
    const hasDuplicates = editedData.some((_, index) => getDuplicateInfo(index).isDuplicate);
    if (hasDuplicates) {
      if (!confirm("Duplicate phone numbers were found. Are you sure you want to save?")) {
        return;
      }
    }
    const finalData = editedData
      .map(c => ({
        ...c,
        phone: toE164(c.phone),
      }))
      .filter(contact => contact.name.trim() !== "" || contact.phone.trim() !== "");
    onSave(finalData);
  };

  const handleDeleteDuplicates = () => {
    const nonDuplicates = editedData.filter((_, index) => !getDuplicateInfo(index).isDuplicate);
    setEditedData(nonDuplicates);
    validateAllPhones(nonDuplicates);
  };

  const hasDuplicates = editedData.some((_, index) => getDuplicateInfo(index).isDuplicate);

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent className="sm:max-w-3xl">
        <TooltipProvider>
          <DialogHeader>
            <DialogTitle>Verify Information</DialogTitle>
            <DialogDescription>
              Review and edit contacts. The AI has predicted the gender.
            </DialogDescription>
          </DialogHeader>
          <div className="max-h-[60vh] overflow-y-auto pr-2">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Name</TableHead>
                  <TableHead>Phone Number</TableHead>
                  <TableHead>Gender</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {editedData.map((contact, index) => {
                  const duplicateInfo = getDuplicateInfo(index);
                  const isInvalid = !!validationErrors[index];
                  const highlightClass = duplicateInfo.isDuplicate
                    ? "bg-red-100 dark:bg-red-900/50 hover:bg-red-200 dark:hover:bg-red-800/60"
                    : "";
                  const tableRow = (
                      <TableRow className={cn("transition-colors", highlightClass)}>
                        <TableCell>
                          <Input
                            value={contact.name}
                            onChange={(e) => handleInputChange(index, 'name', e.target.value)}
                            placeholder="Enter name..."
                            className="bg-transparent"
                          />
                        </TableCell>
                        <TableCell className="align-top">
                          <Input
                            value={contact.phone}
                            onChange={(e) => handleInputChange(index, 'phone', e.target.value)}
                            placeholder="e.g., +44 7700 900123"
                            className={cn(
                              "bg-transparent",
                              isInvalid && "border-red-500 text-red-900 focus-visible:ring-red-500"
                            )}
                          />
                          {isInvalid && (
                            <p className="text-xs text-red-600 mt-1 flex items-center">
                              <AlertCircle className="h-3 w-3 mr-1 flex-shrink-0" />
                              {validationErrors[index]}
                            </p>
                          )}
                        </TableCell>
                        <TableCell>
                          <Select
                            value={contact.gender}
                            onValueChange={(value) => handleInputChange(index, 'gender', value)}
                          >
                            <SelectTrigger>
                              <SelectValue placeholder="Select gender" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="male">Male</SelectItem>
                              <SelectItem value="female">Female</SelectItem>
                              <SelectItem value="unknown">Unknown</SelectItem>
                            </SelectContent>
                          </Select>
                        </TableCell>
                        <TableCell className="text-right">
                          <Button variant="ghost" size="icon" onClick={() => removeContact(index)}>
                            <Trash2 className="h-4 w-4 text-red-500" />
                          </Button>
                        </TableCell>
                      </TableRow>
                  );

                  return (
                    <React.Fragment key={index}>
                      {duplicateInfo.isDuplicate ? (
                        <Tooltip delayDuration={300}>
                          <TooltipTrigger asChild>{tableRow}</TooltipTrigger>
                          <TooltipContent>
                            <p>Duplicate of row #{duplicateInfo.originalIndex! + 1} ({editedData[duplicateInfo.originalIndex!].name})</p>
                          </TooltipContent>
                        </Tooltip>
                      ) : (
                        tableRow
                      )}
                    </React.Fragment>
                  );
                })}
              </TableBody>
            </Table>
          </div>
          <div className="pt-4">
            <Button variant="outline" className="w-full" onClick={addContact}>
              <PlusCircle className="mr-2 h-4 w-4" /> Add Contact
            </Button>
          </div>
          <DialogFooter className="sm:justify-between">
            {hasDuplicates ? (
              <Button variant="destructive" onClick={handleDeleteDuplicates}>
                Delete all Duplicates
              </Button>
            ) : (
              <div />
            )}
            <Button type="submit" onClick={handleSaveClick}>Save All Contacts</Button>
          </DialogFooter>
        </TooltipProvider>
      </DialogContent>
    </Dialog>
  );
}

=== FILE: \src\components\your-data-table.tsx ===

"use client"

import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { columns, Contact } from "./columns"

// UPDATED: Add handler functions to the props
interface DataTableProps<TData, TValue> {
  data: TData[]
  handleDeleteRow: (index: number) => void
  handleEditRow: (index: number, contact: Contact) => void
}

export function YourDataTable<TData, TValue>({
  data,
  handleDeleteRow,
  handleEditRow,
}: DataTableProps<TData, TValue>) {
  const table = useReactTable({
    data,
    columns: columns as ColumnDef<TData, TValue>[],
    getCoreRowModel: getCoreRowModel(),
    // UPDATED: Pass the handler functions into the table's "meta" property
    meta: {
      handleDeleteRow,
      handleEditRow,
    },
  })

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                )
              })}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
              >
                {row.getVisibleCells().map((cell) => (
                  <TableCell key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No contacts added yet.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  )
}

=== FILE: \src\lib\utils.ts ===

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
