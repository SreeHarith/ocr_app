

=== FILE: \src\app\api\contacts\route.ts ===

import { NextRequest, NextResponse } from 'next/server';
import clientPromise from '@/lib/mongodb';
import { Collection } from 'mongodb';
import { Contact } from '@/components/columns';

// ================== ADD THIS LINE ==================
// This forces the route to be dynamic, preventing caching.
export const dynamic = 'force-dynamic';
// ===================================================

export async function POST(request: NextRequest) {
  try {
    const contacts: Contact[] = await request.json();
    if (!Array.isArray(contacts) || contacts.length === 0) {
      return NextResponse.json({ message: 'No contacts provided.' }, { status: 400 });
    }
    const client = await clientPromise;
    const db = client.db();
    const contactsCollection: Collection<Contact> = db.collection('contacts');
    const result = await contactsCollection.insertMany(contacts);
    return NextResponse.json({ 
      message: `${result.insertedCount} contacts saved successfully.`,
      insertedIds: result.insertedIds 
    }, { status: 201 });
  } catch (error) {
    console.error('Failed to save contacts:', error);
    return NextResponse.json({ message: 'Failed to save contacts.' }, { status: 500 });
  }
}

export async function GET() {
  try {
    const client = await clientPromise;
    const db = client.db();

    const contacts = await db
      .collection('contacts')
      .find({})
      .sort({ _id: -1 })
      .toArray();
    
    const sanitizedContacts = contacts.map((contact) => ({
      ...contact,
      _id: contact._id.toString(),
    }));

    return NextResponse.json(sanitizedContacts, { status: 200 });
  } catch (error) {
    console.error('Failed to fetch contacts:', error);
    return NextResponse.json({ message: 'Failed to fetch contacts.' }, { status: 500 });
  }
}

=== FILE: \src\app\api\contacts\validate\route.ts ===

import { NextRequest, NextResponse } from 'next/server';
import clientPromise from '@/lib/mongodb';
import { parsePhoneNumberFromString } from 'libphonenumber-js';
import { Contact } from '@/components/columns';
import { normalizeDateString } from '@/lib/dateUtils';

async function getGender(name: string, apiKey: string) {
  const firstName = name.split(' ')[0];
  try {
    const response = await fetch(`https://gender-api.com/get?name=${firstName}&key=${apiKey}`);
    const data = await response.json();
    return data.gender || 'unknown';
  } catch (error) {
    return 'unknown';
  }
}

export async function POST(request: NextRequest) {
  const genderApiKey = process.env.GENDER_API_KEY!;
  try {
    const contacts: Contact[] = await request.json();
    if (!Array.isArray(contacts) || contacts.length === 0) {
      return NextResponse.json({ message: 'No contacts provided.' }, { status: 400 });
    }

    const normalizedContacts = contacts.map(c => ({
      ...c,
      phone: parsePhoneNumberFromString(c.phone, 'IN')?.format('E.164') || c.phone,
    }));

    const phoneNumbers = normalizedContacts.map(c => c.phone).filter(Boolean);
    const client = await clientPromise;
    const db = client.db();
    const existingContacts = await db.collection('contacts').find({ phone: { $in: phoneNumbers } }).toArray();
    const existingPhones = new Map(existingContacts.map(c => [c.phone, c]));

    const validatedContacts: Contact[] = [];
    const seenPhonesInCSV = new Set<string>();

    for (const contact of normalizedContacts) {
      if (!contact.name) {
        validatedContacts.push({ ...contact, status: 'invalid', message: 'Name is missing.' });
        continue;
      }
      if (!contact.phone) {
        validatedContacts.push({ ...contact, status: 'invalid', message: 'Phone is missing.' });
        continue;
      }

      const phoneNumber = parsePhoneNumberFromString(contact.phone, 'IN');
      if (!phoneNumber || !phoneNumber.isValid()) {
        validatedContacts.push({ ...contact, status: 'invalid', message: 'Invalid phone number format.' });
        continue;
      }
      
      if (existingPhones.has(contact.phone)) {
        const existingContact = existingPhones.get(contact.phone);
        validatedContacts.push({ ...contact, status: 'duplicate', message: `Exists in DB as '${existingContact?.name}'.` });
        continue;
      }
      
      if (seenPhonesInCSV.has(contact.phone)) {
        validatedContacts.push({ ...contact, status: 'duplicate', message: 'Duplicate within this file.' });
        continue;
      }
      
      seenPhonesInCSV.add(contact.phone);
      
      if (!contact.gender || contact.gender === 'unknown') {
        contact.gender = await getGender(contact.name, genderApiKey);
      }
      
      validatedContacts.push({ 
        ...contact, 
        status: 'new', 
        message: 'Ready to import.',
        birthday: normalizeDateString(contact.birthday),
        anniversary: normalizeDateString(contact.anniversary)
      });
    }

    return NextResponse.json(validatedContacts, { status: 200 });
  } catch (error) {
    console.error('Validation error:', error);
    return NextResponse.json({ message: 'Failed to validate contacts.' }, { status: 500 });
  }
}



=== FILE: \src\app\api\contacts\[id]\route.ts ===

import { NextRequest, NextResponse } from 'next/server';
import clientPromise from '@/lib/mongodb';
import { ObjectId } from 'mongodb';
import { normalizeDateString } from '@/lib/dateUtils';

function isValidObjectId(id: string) {
    return ObjectId.isValid(id) && String(new ObjectId(id)) === id;
}

export async function PUT(request: NextRequest, { params }: { params: { id: string } }) {
  const id = params.id;
  if (!isValidObjectId(id)) {
    return NextResponse.json({ message: 'Invalid Contact ID format' }, { status: 400 });
  }

  try {
    const { name, phone, gender, birthday, anniversary } = await request.json();
    if (!name || !phone || !gender) {
        return NextResponse.json({ message: 'Missing required fields' }, { status: 400 });
    }

    const client = await clientPromise;
    const db = client.db();
    const result = await db.collection('contacts').updateOne(
      { _id: new ObjectId(id) },
      { $set: { 
          name, 
          phone, 
          gender, 
          birthday: normalizeDateString(birthday),
          anniversary: normalizeDateString(anniversary) 
        } 
      }
    );

    if (result.matchedCount === 0) {
        return NextResponse.json({ message: 'Contact not found' }, { status: 404 });
    }

    return NextResponse.json({ message: 'Contact updated successfully' }, { status: 200 });
  } catch (error) {
    console.error('Failed to update contact:', error);
    return NextResponse.json({ message: 'Failed to update contact.' }, { status: 500 });
  }
}

export async function DELETE(request: NextRequest, { params }: { params: { id: string } }) {
    const id = params.id;
    if (!isValidObjectId(id)) {
        return NextResponse.json({ message: 'Invalid Contact ID format' }, { status: 400 });
    }
    
    try {
      const client = await clientPromise;
      const db = client.db();
      const result = await db.collection('contacts').deleteOne({ _id: new ObjectId(id) });
  
      if (result.deletedCount === 0) {
        return NextResponse.json({ message: 'Contact not found' }, { status: 404 });
      }
  
      return NextResponse.json({ message: 'Contact deleted successfully' }, { status: 200 });
    } catch (error) {
      console.error('Failed to delete contact:', error);
      return NextResponse.json({ message: 'Failed to delete contact.' }, { status: 500 });
    }
}



=== FILE: \src\app\api\ocr\route.ts ===

import { NextRequest, NextResponse } from 'next/server';
import clientPromise from '@/lib/mongodb';
import { parsePhoneNumberFromString } from 'libphonenumber-js';
import { Contact } from '@/components/columns';
import { normalizeDateString } from '@/lib/dateUtils';

async function getGender(name: string, apiKey: string) {
  const firstName = name.split(' ')[0];
  try {
    const response = await fetch(`https://gender-api.com/get?name=${firstName}&key=${apiKey}`);
    const data = await response.json();
    return data.gender || 'unknown';
  } catch (error) {
    console.error("Gender-API.com call failed:", error);
    return 'unknown';
  }
}

export async function POST(request: NextRequest) {
  const { imageUrl } = await request.json();
  const genderApiKey = process.env.GENDER_API_KEY!;
  
  if (!imageUrl) {
    return NextResponse.json({ error: 'No image URL provided' }, { status: 400 });
  }

  try {
    const ocrResponse = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'qwen/qwen2.5-vl-72b-instruct',
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: 'You are an expert OCR system. Analyze the image to find ALL names, phone numbers, birthdays, and anniversaries. Return ONLY a single, clean JSON array. Each object must have "name", "phone", "birthday", and "anniversary" keys. If a field is not found, its value should be null. Example: [{"name": "John Doe", "phone": "1112223300", "birthday": "1990-05-15", "anniversary": null}]',
              },
              { type: 'image_url', image_url: { url: imageUrl } },
            ],
          },
        ],
      }),
    });

    const ocrData = await ocrResponse.json();

    if (!ocrResponse.ok || !ocrData.choices || ocrData.choices.length === 0) {
      console.error("OCR API Error Response:", ocrData); 
      throw new Error(ocrData?.error?.message || 'The OCR API call failed with an empty or invalid response.');
    }

    const content = ocrData.choices[0].message.content;
    const jsonString = content.match(/```json\n([\s\S]*?)\n```/)?.[1] || content;
    const initialContacts: Contact[] = JSON.parse(jsonString);

    const contactsWithGender = await Promise.all(
      initialContacts.map(async (contact) => {
        const gender = contact.gender || await getGender(contact.name, genderApiKey);
        return { ...contact, gender };
      })
    );
    
    const normalizedContacts = contactsWithGender.map(c => ({
        ...c,
        phone: parsePhoneNumberFromString(c.phone, 'IN')?.format('E.164') || c.phone,
    }));

    const phoneNumbers = normalizedContacts.map(c => c.phone);
    const client = await clientPromise;
    const db = client.db();
    const existingContacts = await db.collection('contacts').find({ phone: { $in: phoneNumbers } }).toArray();
    const existingPhones = new Map(existingContacts.map(c => [c.phone, c]));

    const validatedContacts = normalizedContacts.map((contact): Contact => {
        if (!contact.name || !contact.phone) {
            return { ...contact, status: 'invalid', message: 'Missing name or phone.' };
        }
        
        const phoneNumber = parsePhoneNumberFromString(contact.phone, 'IN');
        if (!phoneNumber || !phoneNumber.isValid()) {
            return { ...contact, status: 'invalid', message: 'Invalid phone number format.' };
        }
        
        if (existingPhones.has(contact.phone)) {
            const existing = existingPhones.get(contact.phone);
            return { ...contact, status: 'duplicate', message: `Exists in DB as '${existing?.name}'.` };
        }
        return { 
            ...contact, 
            status: 'new', 
            message: 'Ready to import.',
            birthday: normalizeDateString(contact.birthday),
            anniversary: normalizeDateString(contact.anniversary)
        };
    });

    return NextResponse.json(validatedContacts);

  } catch (error) {
    console.error(error);
    return NextResponse.json({ error: 'Failed to process the image.' }, { status: 500 });
  }
}



=== FILE: \src\app\api\upload\route.ts ===

import { NextRequest, NextResponse } from 'next/server';
import { v2 as cloudinary } from 'cloudinary';

// Configure Cloudinary with your credentials
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function POST(request: NextRequest) {
  const formData = await request.formData();
  const file = formData.get('file') as File;

  if (!file) {
    return NextResponse.json({ error: "No file provided." }, { status: 400 });
  }

  // Convert the file to a buffer
  const buffer = await file.arrayBuffer();
  const bytes = Buffer.from(buffer);

  try {
    const result: any = await new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'ocr-uploads',
          // This transformation creates the JPG version on Cloudinary's servers.
          transformation: [
            { width: 1200, height: 1200, crop: 'limit' },
            { format: 'jpg', quality: 'auto:good' }
          ],
          // ================== ADD THIS LINE ==================
          eager: true, // This tells Cloudinary to process the image immediately.
          // ===================================================
        },
        (error, result) => {
          if (error) {
            reject(error);
          } else {
            resolve(result);
          }
        }
      );
      uploadStream.end(bytes);
    });

    // ================== THE FIX IS HERE ==================
    // The result.secure_url points to the original .heic file.
    // We manually change the extension to .jpg to get the URL for the converted version.
    const transformedUrl = result.secure_url.replace(/\.heic$/i, ".jpg");
    // =====================================================

    // Return the secure URL of the newly converted and optimized JPG image
    return NextResponse.json({ url: transformedUrl });

  } catch (error) {
    console.error("Cloudinary upload error:", error);
    return NextResponse.json({ error: "Failed to upload image to Cloudinary." }, { status: 500 });
  }
}


=== FILE: \src\app\globals.css ===

@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


=== FILE: \src\app\layout.tsx ===

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


=== FILE: \src\app\page.tsx ===

'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { YourDataTable } from '@/components/your-data-table';
import EditDialog from '@/components/edit-dialog';
import { Contact } from '@/components/columns';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import dynamic from 'next/dynamic';
import { Download, Upload, FileImage, Camera, FileText } from 'lucide-react';
import Papa from 'papaparse';

const DynamicCSVLink = dynamic(
  () => import('react-csv').then((mod) => mod.CSVLink),
  { ssr: false }
);

type DialogMode = 'csv' | 'ocr' | 'edit';

export default function Home() {
  const [file, setFile] = useState<File | null>(null);
  const [extractedInfo, setExtractedInfo] = useState<Contact[]>([]);
  const [tableData, setTableData] = useState<Contact[]>([]);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [imagePreviewUrl, setImagePreviewUrl] = useState<string | null>(null);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [isNotFoundDialogOpen, setIsNotFoundDialogOpen] = useState(false);
  const [isCameraOpen, setIsCameraOpen] = useState(false);
  const [cameraStream, setCameraStream] = useState<MediaStream | null>(null);
  const [isTableLoading, setIsTableLoading] = useState(true);
  const [dialogMode, setDialogMode] = useState<DialogMode>('edit');

  const imageInputRef = useRef<HTMLInputElement>(null);
  const csvInputRef = useRef<HTMLInputElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [videoNode, setVideoNode] = useState<HTMLVideoElement | null>(null);

  const videoRef = useCallback((node: HTMLVideoElement) => {
    if (node !== null) setVideoNode(node);
  }, []);

  const fetchContacts = useCallback(async () => {
    setIsTableLoading(true);
    try {
      const response = await fetch('/api/contacts');
      if (!response.ok) throw new Error('Failed to fetch contacts');
      const data = await response.json();
      setTableData(data);
    } catch (error) {
      console.error("Fetch error:", error);
      alert("Could not load contacts from the database.");
    } finally {
      setIsTableLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchContacts();
  }, [fetchContacts]);

  useEffect(() => {
    const handleVideoPlay = () => {
      videoNode?.play().catch(error => console.error("Error trying to play video:", error));
    };
    if (isCameraOpen && cameraStream && videoNode) {
      videoNode.srcObject = cameraStream;
      videoNode.addEventListener('loadedmetadata', handleVideoPlay);
    }
    return () => {
      videoNode?.removeEventListener('loadedmetadata', handleVideoPlay);
    };
  }, [isCameraOpen, cameraStream, videoNode]);
  
  useEffect(() => {
    return () => {
      if (imagePreviewUrl) URL.revokeObjectURL(imagePreviewUrl);
    };
  }, [imagePreviewUrl]);

  const csvHeaders = [
    { label: "name", key: "name" },
    { label: "phone", key: "phone" },
    { label: "gender", key: "gender" },
    { label: "birthday", key: "birthday" },
    { label: "anniversary", key: "anniversary" }
  ];
  
  const sampleCsvData = [
    { name: "Rohan Sharma", phone: "\t+919876543210", gender: "male", birthday: "1992-03-10", anniversary: "" },
    { name: "Priya Patel", phone: "\t+917890123456", gender: "female", birthday: "1995-11-22", anniversary: "2020-06-01" },
  ];

  const getCSVData = () => {
    return tableData.map(contact => ({
      ...contact,
      phone: `\t${contact.phone}`
    }));
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (imagePreviewUrl) URL.revokeObjectURL(imagePreviewUrl);
    const newFile = event.target.files?.[0];
    if (newFile) {
      setFile(newFile);
      setImagePreviewUrl(URL.createObjectURL(newFile));
    } else {
      setFile(null);
      setImagePreviewUrl(null);
    }
    if(event.target) event.target.value = '';
  };

  const handleExtractClick = async () => {
    if (!file) {
      alert('Please select a file first.');
      return;
    }
    setIsLoading(true);
    try {
      const formData = new FormData();
      formData.append('file', file);
      const uploadResponse = await fetch('/api/upload', { method: 'POST', body: formData });
      const uploadData = await uploadResponse.json();
      if (!uploadResponse.ok) throw new Error(uploadData.error || 'Failed to upload image.');
      
      const imageUrl = uploadData.url;
      const ocrResponse = await fetch('/api/ocr', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ imageUrl }),
      });
      const validatedContacts = await ocrResponse.json();
      if (!ocrResponse.ok) throw new Error(validatedContacts.message || 'Failed to process image');

      if (Array.isArray(validatedContacts) && validatedContacts.length > 0) {
        setExtractedInfo(validatedContacts);
        setDialogMode('ocr');
        setIsDialogOpen(true);
      } else {
        setIsNotFoundDialogOpen(true);
      }
    } catch (error: any) {
      alert(`An error occurred: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleCsvImport = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    setIsLoading(true);
    new Promise<Contact[]>((resolve, reject) => {
      Papa.parse(file, {
        header: true, skipEmptyLines: true,
        complete: (results) => {
          const headers = results.meta.fields || [];
          if (!headers.some(h => h.toLowerCase().includes('name')) || !headers.some(h => h.toLowerCase().includes('phone'))) {
            return reject(new Error("Import failed: CSV must contain 'name' and 'phone' columns."));
          }
          const parsed = results.data.map((row: any) => ({ name: row.name || row.Name || '', phone: row.phone || row['Phone Number'] || '', gender: (row.gender || row.Gender || 'unknown').toLowerCase() }));
          resolve(parsed);
        },
        error: (error: any) => reject(error),
      });
    })
    .then(async (parsedContacts) => {
      if (parsedContacts.length === 0) {
        alert("No valid contacts found in the CSV file.");
        return;
      }
      const response = await fetch('/api/contacts/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(parsedContacts),
      });
      const validatedContacts = await response.json();
      if (!response.ok) throw new Error(validatedContacts.message || 'Validation failed.');
      
      setExtractedInfo(validatedContacts);
      setDialogMode('csv');
      setIsDialogOpen(true);
    })
    .catch((err: Error) => {
        alert(err.message);
    })
    .finally(() => {
        setIsLoading(false);
        if(event.target) event.target.value = '';
    });
  };

  const handleOpenCamera = async () => {
    if ('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        setCameraStream(stream);
        setIsCameraOpen(true);
      } catch (err) {
        alert("Could not access the camera. Please check your browser permissions.");
      }
    } else {
      alert("Your browser does not support camera access.");
    }
  };

  const handleCloseCamera = () => {
    cameraStream?.getTracks().forEach(track => track.stop());
    setCameraStream(null);
    setIsCameraOpen(false);
  };
  
  const handleCapture = () => {
    if (videoNode && canvasRef.current) {
      const canvas = canvasRef.current;
      if (videoNode.videoWidth === 0) return;
      canvas.width = videoNode.videoWidth;
      canvas.height = videoNode.videoHeight;
      canvas.getContext('2d')?.drawImage(videoNode, 0, 0, videoNode.videoWidth, videoNode.videoHeight);
      canvas.toBlob((blob) => {
        if (blob) {
          const capturedFile = new File([blob], `capture-${Date.now()}.png`, { type: 'image/png' });
          setFile(capturedFile);
          if (imagePreviewUrl) URL.revokeObjectURL(imagePreviewUrl);
          setImagePreviewUrl(URL.createObjectURL(capturedFile));
        }
      }, 'image/png');
      handleCloseCamera();
    }
  };

  const handleSave = async (data: Contact[]) => {
    if (data.length === 0) { setIsDialogOpen(false); return; }
    const contactToSave = data[0];
    try {
      let response;
      if (dialogMode === 'edit' && editingIndex !== null && contactToSave._id) {
        response = await fetch(`/api/contacts/${contactToSave._id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(contactToSave),
        });
      } else {
        response = await fetch('/api/contacts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
      }
      const result = await response.json();
      if (!response.ok) throw new Error(result.message);
      await fetchContacts();
      alert(result.message);
    } catch (error: any) {
      alert(`Error: ${error.message}`);
    } 
    finally {
      setIsDialogOpen(false);
      setEditingIndex(null);
    }
  };

  const handleDeleteRow = async (index: number) => {
    const contactToDelete = tableData[index];
    if (!contactToDelete._id) return;
    if (confirm('Are you sure you want to delete this contact permanently?')) {
      try {
        const response = await fetch(`/api/contacts/${contactToDelete._id}`, { method: 'DELETE' });
        const result = await response.json();
        if (!response.ok) throw new Error(result.message);
        await fetchContacts();
        alert(result.message);
      } catch (error: any) {
        alert(`Error: ${error.message}`);
      }
    }
  };
  
  const handleEditRow = (index: number, contact: Contact) => {
    setExtractedInfo([contact]);
    setDialogMode('edit');
    setEditingIndex(index);
    setIsDialogOpen(true);
  };

  return (
    <main className="container mx-auto p-4 md:p-8">
      <div className="max-w-4xl mx-auto">
        <header className="mb-8 text-center">
          <h1 className="text-3xl md:text-4xl font-bold">OCR Contact Extractor</h1>
          <p className="text-muted-foreground mt-2">
            Upload, capture, or import a file to extract contact information.
          </p>
        </header>

        <div className="relative p-6 border rounded-lg bg-card shadow-sm mb-8">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-6">
            <div className="flex flex-col gap-3">
              <h3 className="font-semibold text-center md:text-left">Option 1: Extract from Image</h3>
              <div className="flex flex-col sm:flex-row items-center gap-2">
                 <Input
                  id="picture"
                  type="file"
                  ref={imageInputRef}
                  onChange={handleFileChange}
                  className="hidden"
                  accept="image/png, image/jpeg, image/webp"
                />
                <Button 
                  onClick={() => imageInputRef.current?.click()} 
                  variant="outline" 
                  className="w-full sm:w-auto"
                >
                  <FileImage className="mr-2 h-4 w-4" />
                  Choose File
                </Button>
                <Button 
                  onClick={handleOpenCamera} 
                  variant="outline" 
                  className="w-full sm:w-auto"
                >
                  <Camera className="mr-2 h-4 w-4" />
                  Use Camera
                </Button>
              </div>
              {file && (
                <p className="text-sm text-muted-foreground text-center sm:text-left truncate">
                  Selected: <strong>{file.name}</strong>
                </p>
              )}
               <Button 
                  onClick={handleExtractClick} 
                  disabled={!file || isLoading} 
                  className="w-full"
                >
                  {isLoading ? 'Processing...' : 'Extract from Image'}
                </Button>
            </div>
            <div className="flex flex-col gap-3">
              <h3 className="font-semibold text-center md:text-left">Option 2: Import from CSV</h3>
              <div className="flex flex-col sm:flex-row items-center justify-center md:justify-start gap-4">
                <Input
                  type="file"
                  ref={csvInputRef}
                  onChange={handleCsvImport}
                  className="hidden"
                  accept=".csv"
                />
                <Button 
                  onClick={() => csvInputRef.current?.click()} 
                  variant="outline"
                >
                  <Upload className="mr-2 h-4 w-4" />
                  Import CSV File
                </Button>
                
                <DynamicCSVLink
                  data={sampleCsvData}
                  headers={csvHeaders}
                  filename={"contacts-template.csv"}
                  className="text-sm text-muted-foreground hover:text-foreground transition-colors flex items-center gap-1 whitespace-nowrap"
                >
                  <FileText className="h-4 w-4" />
                  Download Template
                </DynamicCSVLink>
              </div>
            </div>
          </div>
          <div className="absolute top-4 bottom-4 left-1/2 -translate-x-1/2 w-px bg-border hidden md:block" />
        </div>

        {imagePreviewUrl && (
          <div className="mb-8">
            <h2 className="text-xl font-semibold mb-4 text-center">Image Preview</h2>
            <div className="flex justify-center">
              <div className="p-2 border-2 border-dashed rounded-lg">
                <img
                  src={imagePreviewUrl}
                  alt="Uploaded contact card"
                  className="max-w-md max-h-96 rounded-md object-contain"
                />
              </div>
            </div>
          </div>
        )}
        
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-semibold">Saved Contacts</h2>
          {tableData.length > 0 && (
            <DynamicCSVLink
              data={getCSVData()}
              headers={csvHeaders}
              filename={"contacts.csv"}
              className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-secondary text-secondary-foreground hover:bg-secondary/80 h-10 px-4 py-2"
            >
              <Download className="mr-2 h-4 w-4" />
              Download CSV
            </DynamicCSVLink>
          )}
        </div>
        
        <YourDataTable
          data={tableData}
          isLoading={isTableLoading}
          handleDeleteRow={handleDeleteRow}
          handleEditRow={handleEditRow}
        />

        <EditDialog
          isOpen={isDialogOpen}
          setIsOpen={setIsDialogOpen}
          data={extractedInfo}
          onSave={handleSave}
          mode={dialogMode}
        />
        
        <AlertDialog open={isNotFoundDialogOpen} onOpenChange={setIsNotFoundDialogOpen}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>No Contacts Found</AlertDialogTitle>
              <AlertDialogDescription>
                We could not detect a name or phone number in the uploaded image. Please try a different image or one with clearer text.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogAction>OK</AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        <Dialog open={isCameraOpen} onOpenChange={(open) => !open && handleCloseCamera()}>
          <DialogContent className="max-w-xl">
            <DialogHeader>
              <DialogTitle>Capture Image</DialogTitle>
            </DialogHeader>
            <video ref={videoRef} autoPlay playsInline muted className="w-full aspect-video rounded-md border bg-black" />
            <canvas ref={canvasRef} className="hidden" />
            <DialogFooter className="gap-2 sm:justify-center">
              <Button variant="outline" onClick={handleCloseCamera}>Cancel</Button>
              <Button onClick={handleCapture}>
                <Camera className="mr-2 h-4 w-4" />
                Capture Photo
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </main>
  );
}

=== FILE: \src\components\columns.tsx ===

"use client"

import { ColumnDef } from "@tanstack/react-table"
import { Button } from "@/components/ui/button"
import { Edit, Trash2 } from "lucide-react"

export type Contact = {
  _id?: string
  name: string
  phone: string
  gender: string
  // FIX: Changed from undefined to null to match the date function's output
  birthday?: string | null
  anniversary?: string | null
  status?: 'new' | 'duplicate' | 'invalid'
  message?: string
}

export const columns: ColumnDef<Contact>[] = [
  {
    accessorKey: "name",
    header: "Name",
  },
  {
    accessorKey: "phone",
    header: "Phone Number",
  },
  {
    accessorKey: "gender",
    header: "Gender",
    cell: ({ row }) => <div className="capitalize">{row.getValue("gender")}</div>,
  },
  {
    accessorKey: "birthday",
    header: "Birthday",
  },
  {
    accessorKey: "anniversary",
    header: "Anniversary",
  },
  {
    id: "actions",
    header: () => <div className="text-right">Actions</div>,
    cell: ({ row, table }) => {
      const contact = row.original
      return (
        <div className="text-right">
          <Button
            variant="ghost"
            size="icon"
            // @ts-ignore
            onClick={() => table.options.meta?.handleEditRow(row.index, contact)}
            className="mr-2"
          >
            <Edit className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            // @ts-ignore
            onClick={() => table.options.meta?.handleDeleteRow(row.index)}
          >
            <Trash2 className="h-4 w-4 text-red-500" />
          </Button>
        </div>
      )
    },
  },
]


=== FILE: \src\components\edit-dialog.tsx ===

"use client"

import { useEffect, useState, ReactNode } from "react"
import { Button } from "@/components/ui/button"
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Input } from "@/components/ui/input"
import { Checkbox } from "@/components/ui/checkbox"
import { Trash2, PlusCircle, AlertCircle, CheckCircle, Copy, Info } from "lucide-react"
import { cn } from "@/lib/utils"
import { parsePhoneNumberFromString, CountryCode } from "libphonenumber-js"
import { Contact } from "./columns"

type DialogMode = 'csv' | 'ocr' | 'edit';

interface EditDialogProps {
  isOpen: boolean;
  setIsOpen: (isOpen: boolean) => void;
  data: Contact[];
  onSave: (data: Contact[]) => void;
  mode: DialogMode;
}

const DEFAULT_COUNTRY: CountryCode = "IN";

const toE164 = (raw: string, country?: CountryCode): string => {
  const parsed = parsePhoneNumberFromString(raw?.trim() ?? "", country || DEFAULT_COUNTRY);
  return parsed?.number ?? (raw?.trim() ?? "");
};

const getValidationError = (name: string, phone: string): string | null => {
  if (!name || !name.trim()) return "Name is required.";
  if (!phone || !phone.trim()) return "Phone is required.";
  const parsed = parsePhoneNumberFromString(phone, DEFAULT_COUNTRY);
  if (!parsed || !parsed.isValid()) {
    return "Invalid phone number format.";
  }
  if (parsed.country === 'IN') {
    if (!/^[6789]\d{9}$/.test(parsed.nationalNumber)) {
      return "Invalid Indian mobile number.";
    }
  }
  return null;
};

export default function EditDialog({ isOpen, setIsOpen, data, onSave, mode }: EditDialogProps) {
  const [editedData, setEditedData] = useState<Contact[]>([]);
  const [selectedRows, setSelectedRows] = useState<Record<number, boolean>>({});

  const runInternalValidation = (contacts: Contact[]): Contact[] => {
    const seenPhones = new Set<string>();
    return contacts.map(contact => {
      if (contact.status === 'duplicate' && contact.message?.includes('Exists in DB')) {
        seenPhones.add(toE164(contact.phone));
        return contact;
      }
      const phoneE164 = toE164(contact.phone);
      const validationError = getValidationError(contact.name, contact.phone);
      if (validationError) {
        return { ...contact, status: 'invalid', message: validationError };
      }
      if (phoneE164 && seenPhones.has(phoneE164)) {
          return { ...contact, status: 'duplicate', message: 'Duplicate within this list.' };
      }
      if(phoneE164) seenPhones.add(phoneE164);
      return { ...contact, status: 'new', message: 'Ready to save.' };
    });
  };

  useEffect(() => {
    if (data) {
        const processedData = runInternalValidation(data);
        setEditedData(processedData);
        const initialSelection: Record<number, boolean> = {};
        if (mode === 'csv') {
            processedData.forEach((contact, index) => {
            if (contact.status === 'new') initialSelection[index] = true;
            });
        }
        setSelectedRows(initialSelection);
    }
  }, [data, mode]);

  const handleInputChange = (index: number, field: 'name' | 'phone' | 'gender' | 'birthday' | 'anniversary', value: string) => {
    setEditedData(prevData => {
      const updated = [...prevData];
      updated[index] = { ...updated[index], [field]: value };
      return runInternalValidation(updated);
    });
  };
  
  const removeContact = (index: number) => {
    setEditedData(prev => runInternalValidation(prev.filter((_, i) => i !== index)));
  };

  const addContact = () => {
    const newContact: Contact = { name: "", phone: "", gender: "unknown", status: 'invalid', message: 'Name is required.' };
    setEditedData(prev => [...prev, newContact]);
  }

  const handleSaveClick = () => {
    if (mode === 'csv') {
      const dataToSave = editedData.filter((_, index) => selectedRows[index]);
      onSave(dataToSave);
    } else {
      if (editedData.some(c => c.status === 'invalid')) {
        alert("Please fix all invalid contacts before saving.");
        return;
      }
      const dataToSave = editedData.filter(c => c.status !== 'duplicate');
      onSave(dataToSave);
    }
  };
  
  const handleRemoveDuplicates = () => {
    setEditedData(prev => prev.filter(c => c.status !== 'duplicate'));
  };

  const handleRemoveInvalids = () => {
    setEditedData(prev => prev.filter(c => c.status !== 'invalid'));
  };

  const getStatusIcon = (status?: string): ReactNode => {
    switch (status) {
      case 'new': return <CheckCircle className="h-4 w-4 text-green-500" />;
      case 'duplicate': return <Copy className="h-4 w-4 text-yellow-500" />;
      case 'invalid': return <AlertCircle className="h-4 w-4 text-red-500" />;
      default: return null;
    }
  };
  
  const getRowClass = (status?: string): string => {
    if (status === 'duplicate') return "bg-yellow-50 dark:bg-yellow-900/20";
    if (status === 'invalid') return "bg-red-50 dark:bg-red-900/20";
    return "";
  };
  
  const hasDuplicates = editedData.some(c => c.status === 'duplicate');
  const hasInvalids = editedData.some(c => c.status === 'invalid');

  const tableHeaders: ReactNode[] = [];
  if (mode === 'csv') {
    tableHeaders.push(<TableHead key="select" className="w-[50px]"><Checkbox 
        onCheckedChange={(checked) => {
            const newSelection: Record<number, boolean> = {};
            if(checked) editedData.forEach((c, i) => { if(c.status === 'new') newSelection[i] = true; });
            setSelectedRows(newSelection);
        }}
    /></TableHead>);
  }
  tableHeaders.push(<TableHead key="name">Name</TableHead>);
  tableHeaders.push(<TableHead key="phone">Phone Number</TableHead>);
  tableHeaders.push(<TableHead key="gender">Gender</TableHead>);
  tableHeaders.push(<TableHead key="birthday">Birthday</TableHead>);
  tableHeaders.push(<TableHead key="anniversary">Anniversary</TableHead>);
  if (mode !== 'edit') {
    tableHeaders.push(<TableHead key="status">Status</TableHead>);
  }
  if (mode !== 'csv') {
    tableHeaders.push(<TableHead key="actions" className="text-right">Actions</TableHead>);
  }

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogContent className="sm:max-w-7xl">
        <DialogHeader>
          <DialogTitle>Verify Information</DialogTitle>
          <DialogDescription>
            {mode === 'csv' && "Review contacts from your CSV. Only selected rows will be imported."}
            {mode === 'ocr' && "Review contacts from the image. Duplicates and invalid rows will not be saved."}
            {mode === 'edit' && "Edit the contact's details before saving."}
          </DialogDescription>
        </DialogHeader>
        <div className="max-h-[60vh] overflow-y-auto pr-2">
          <Table>
            <TableHeader>
              <TableRow>{tableHeaders}</TableRow>
            </TableHeader>
            <TableBody>
              {editedData.map((contact, index) => (
                <TableRow key={index} className={getRowClass(contact.status)}>
                  {mode === 'csv' && <TableCell><Checkbox 
                    checked={selectedRows[index] || false}
                    onCheckedChange={(checked) => setSelectedRows(prev => ({...prev, [index]: !!checked}))}
                    disabled={contact.status !== 'new'}
                  /></TableCell>}
                  <TableCell><Input value={contact.name} onChange={(e) => handleInputChange(index, 'name', e.target.value)} /></TableCell>
                  <TableCell><Input value={contact.phone} onChange={(e) => handleInputChange(index, 'phone', e.target.value)} /></TableCell>
                  <TableCell>
                    <Select value={contact.gender} onValueChange={(value) => handleInputChange(index, 'gender', value)}>
                      <SelectTrigger><SelectValue /></SelectTrigger>
                      <SelectContent>
                        <SelectItem value="male">Male</SelectItem>
                        <SelectItem value="female">Female</SelectItem>
                        <SelectItem value="unknown">Unknown</SelectItem>
                      </SelectContent>
                    </Select>
                  </TableCell>
                  <TableCell><Input type="date" value={contact.birthday || ''} onChange={(e) => handleInputChange(index, 'birthday', e.target.value)} /></TableCell>
                  <TableCell><Input type="date" value={contact.anniversary || ''} onChange={(e) => handleInputChange(index, 'anniversary', e.target.value)} /></TableCell>
                  {(mode !== 'edit') && <TableCell><div className="flex items-center gap-2" title={contact.message}>{getStatusIcon(contact.status)} <span className="text-xs text-muted-foreground truncate">{contact.message}</span></div></TableCell>}
                  {(mode !== 'csv') && <TableCell className="text-right"><Button variant="ghost" size="icon" onClick={() => removeContact(index)}><Trash2 className="h-4 w-4 text-red-500" /></Button></TableCell>}
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </div>
        
        <div className="pt-4 flex flex-wrap gap-2">
          {(mode === 'ocr' || mode === 'edit') && 
            <Button variant="outline" onClick={addContact}><PlusCircle className="mr-2 h-4 w-4" /> Add Contact</Button>
          }
          {hasDuplicates && 
            <Button variant="outline" onClick={handleRemoveDuplicates} className="text-yellow-600 border-yellow-300 hover:bg-yellow-50">Remove Duplicates</Button>
          }
          {hasInvalids && 
            <Button variant="outline" onClick={handleRemoveInvalids} className="text-red-600 border-red-300 hover:bg-red-50">Remove Invalid Rows</Button>
          }
        </div>
        
        <DialogFooter>
          <Button variant="outline" onClick={() => setIsOpen(false)}>Cancel</Button>
          <Button onClick={handleSaveClick}>
            {mode === 'csv' ? 'Save Selected Contacts' : 'Save Contacts'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


=== FILE: \src\components\your-data-table.tsx ===

"use client"

import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  useReactTable,
} from "@tanstack/react-table"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { columns, Contact } from "./columns"

interface DataTableProps<TData, TValue> {
  data: TData[]
  isLoading: boolean
  handleDeleteRow: (index: number) => void
  handleEditRow: (index: number, contact: Contact) => void
}

export function YourDataTable<TData, TValue>({
  data,
  isLoading,
  handleDeleteRow,
  handleEditRow,
}: DataTableProps<TData, TValue>) {
  const table = useReactTable({
    data,
    columns: columns as ColumnDef<TData, TValue>[],
    getCoreRowModel: getCoreRowModel(),
    meta: {
      handleDeleteRow,
      handleEditRow,
    },
  })

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                )
              })}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {isLoading ? (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-24 text-center">
                Loading contacts...
              </TableCell>
            </TableRow>
          ) : table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
              >
                {row.getVisibleCells().map((cell) => (
                  <TableCell key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No contacts saved in the database.
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>
    </div>
  )
}

=== FILE: \src\lib\dateUtils.ts ===

import { format, isValid, parseISO } from 'date-fns';

/**
 * Normalizes a date string from various formats into 'yyyy-MM-dd'.
 * @param dateInput The date string to normalize (e.g., "18/09/2025", "2025-09-18", etc.)
 * @returns A string in 'yyyy-MM-dd' format, or null if the input is invalid or empty.
 */
export function normalizeDateString(dateInput: string | null | undefined): string | null {
  if (!dateInput || typeof dateInput !== 'string' || dateInput.trim() === '') {
    return null;
  }

  // The native Date constructor is surprisingly good at parsing common formats
  const date = new Date(dateInput);

  // For ISO strings like "YYYY-MM-DDTHH:mm:ss.sssZ", the timezone can cause an off-by-one day error.
  // We can correct this by parsing it as ISO and grabbing the UTC parts.
  if (dateInput.includes('T') && dateInput.includes('Z')) {
      const parsedIso = parseISO(dateInput);
      if (isValid(parsedIso)) {
        return format(parsedIso, 'yyyy-MM-dd');
      }
  }

  if (isValid(date)) {
    // Check if the constructor misinterpreted a number as a year (e.g., '10-12-23')
    // This is a simple heuristic to avoid common misinterpretations
    if(date.getFullYear() < 1900) return null;

    return format(date, 'yyyy-MM-dd');
  }

  return null; // Return null if the date string is not valid
}

=== FILE: \src\lib\mongodb.ts ===

import { MongoClient } from 'mongodb'

if (!process.env.MONGODB_URI) {
  throw new Error('Invalid/Missing environment variable: "MONGODB_URI"')
}

const uri = process.env.MONGODB_URI
const options = {}

let client
let clientPromise: Promise<MongoClient>

if (process.env.NODE_ENV === 'development') {
  // In development mode, use a global variable so that the value
  // is preserved across module reloads caused by HMR (Hot Module Replacement).
  let globalWithMongo = global as typeof globalThis & {
    _mongoClientPromise?: Promise<MongoClient>
  }

  if (!globalWithMongo._mongoClientPromise) {
    client = new MongoClient(uri, options)
    globalWithMongo._mongoClientPromise = client.connect()
  }
  clientPromise = globalWithMongo._mongoClientPromise
} else {
  // In production mode, it's best to not use a global variable.
  client = new MongoClient(uri, options)
  clientPromise = client.connect()
}

// Export a module-scoped MongoClient promise. By doing this in a
// separate module, the client can be shared across functions.
export default clientPromise

=== FILE: \src\lib\utils.ts ===

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
